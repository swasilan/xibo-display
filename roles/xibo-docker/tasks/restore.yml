---
# --------------------------------------------------
# Variablen definieren
# --------------------------------------------------
- name: Set restore paths
  set_fact:
    restore_tmp_dir: /tmp/xibo_restore
    backup_dir: /opt/xibo-backup/backups
    cms_target_dir: /opt/xibo-docker/shared/cms

# --------------------------------------------------
# PrÃ¼fen, ob Restore-Verzeichnisse existieren
# --------------------------------------------------
- name: Ensure backup directory exists
  file:
    path: /opt/xibo-backup/backups
    state: directory
    owner: xibo
    group: xibo
    mode: '0755'

- name: Ensure CMS directory exists
  file:
    path: /opt/xibo-docker/shared/cms
    state: directory
    owner: xibo
    group: xibo
    mode: '0755'

- name: Check if backup directory exists
  stat:
    path: "{{ backup_dir }}"
  register: backup_dir_stat

- name: Check if CMS target directory exists
  stat:
    path: "{{ cms_target_dir }}"
  register: cms_dir_stat

- name: Abort if required directories do not exist
  fail:
    msg: "âŒ Restore-Verzeichnisse existieren nicht. Restore wird abgebrochen."
  when: not (backup_dir_stat.stat.exists and cms_dir_stat.stat.exists)

# --------------------------------------------------
# Backup finden
# --------------------------------------------------
- name: Find available Xibo backups
  find:
    paths: "{{ backup_dir }}"
    patterns: "xibo_backup_*.zip"
    recurse: no
  register: found_backups
  when: backup_dir_stat.stat.exists

- name: Abort if no backups found
  fail:
    msg: "âŒ Keine Xibo Backups gefunden in {{ backup_dir }}"
  when: backup_dir_stat.stat.exists and (found_backups.files | length == 0)

- name: Show available backups
  debug:
    msg: |
      VerfÃ¼gbare Backups:
      {% for f in found_backups.files | sort(attribute='mtime', reverse=true) %}
      - {{ loop.index }}: {{ f.path }} ({{ f.mtime | to_datetime }})
      {% endfor %}
  when: backup_dir_stat.stat.exists and (found_backups.files | length > 0)

# --------------------------------------------------
# Benutzer fragen
# --------------------------------------------------
- name: Ask if restore should be executed
  pause:
    prompt: |
      âš ï¸  Es wurden {{ found_backups.files | length }} Backup(s) gefunden.
      MÃ¶chtest du ein Backup wiederherstellen?
      Tippe 'yes' zum Fortfahren:
  register: restore_confirm
  when: backup_dir_stat.stat.exists and (found_backups.files | length > 0)

- name: Abort restore
  fail:
    msg: "Restore vom Benutzer abgebrochen."
  when: restore_confirm.user_input != "yes"

- name: Ask which backup to restore
  pause:
    prompt: |
      Bitte Nummer des Backups angeben (1â€“{{ found_backups.files | length }}):
  register: backup_choice
  when: restore_confirm.user_input == "yes"

- name: Validate backup selection
  fail:
    msg: "UngÃ¼ltige Auswahl."
  when: backup_choice.user_input | int < 1 or backup_choice.user_input | int > found_backups.files | length

- name: Select chosen backup
  set_fact:
    selected_backup: >-
      {{ (found_backups.files | sort(attribute='mtime', reverse=true))
         [backup_choice.user_input | int - 1].path }}
  when: restore_confirm.user_input == "yes"

- name: Confirm selected backup
  debug:
    msg: "âœ… GewÃ¤hltes Backup: {{ selected_backup }}"
  when: restore_confirm.user_input == "yes"

# --------------------------------------------------
# Restore vorbereiten
# --------------------------------------------------
- name: Ensure restore temp directory exists
  file:
    path: "{{ restore_tmp_dir }}"
    state: directory
    mode: "0755"
  when: restore_confirm.user_input == "yes"

# --------------------------------------------------
# Backup entpacken
# --------------------------------------------------
- name: Unarchive selected backup
  unarchive:
    src: "{{ selected_backup }}"
    dest: "{{ restore_tmp_dir }}"
    remote_src: yes
  when: restore_confirm.user_input == "yes"

# --------------------------------------------------
# Datenbank Restore
# --------------------------------------------------
- name: Copy DB dump into DB container
  command: >
    docker cp {{ restore_tmp_dir }}/db.sql
    {{ xibo_db_container }}:/db.sql
  when: restore_confirm.user_input == "yes"

- name: Restore database
  shell: |
    docker exec {{ xibo_db_container }} \
      mysql -u{{ xibo_db_user }} -p{{ xibo_db_password }} {{ xibo_db_name }} < /db.sql
  changed_when: true
  when: restore_confirm.user_input == "yes"

# --------------------------------------------------
# CMS Dateien Restore
# --------------------------------------------------
- name: Restore CMS files
  shell: |
    rsync -a --delete \
      {{ restore_tmp_dir }}/cms/ \
      {{ cms_target_dir }}/
  changed_when: true
  when: restore_confirm.user_input == "yes"

# --------------------------------------------------
# Cleanup
# --------------------------------------------------
- name: Cleanup restore temp directory
  file:
    path: "{{ restore_tmp_dir }}"
    state: absent
  when: restore_confirm.user_input == "yes"

- name: Restore finished
  debug:
    msg: "ðŸŽ‰ Restore erfolgreich abgeschlossen."
  when: restore_confirm.user_input == "yes"
