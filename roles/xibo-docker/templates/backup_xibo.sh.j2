{% raw %}
#!/usr/bin/env bash
set -euo pipefail
{% endraw %}

# --------------------------------------------------
# Konfiguration (per Ansible)
# --------------------------------------------------
BACKUP_BASE="/opt/xibo-backup"
BACKUP_DIR="$BACKUP_BASE/backups"
LOG_DIR="$BACKUP_BASE/logs"

DB_CONTAINER="{{ xibo_db_container }}"
DB_NAME="{{ xibo_db_name }}"
DB_USER="{{ xibo_db_user }}"
DB_PASS="{{ xibo_db_password }}"

CMS_PATH="/opt/xibo-docker/shared/cms"

MIN_BACKUPS=5
MAX_BACKUPS=30

{% raw %}
# --------------------------------------------------
# Setup
# --------------------------------------------------
mkdir -p "$BACKUP_DIR" "$LOG_DIR"

TMP_DIR="$(mktemp -d)"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"
LOG_FILE="$LOG_DIR/backup_$(date +'%F').log"

exec >>"$LOG_FILE" 2>&1

log() {
  echo "[$(date '+%F %T')] $*"
}

trap 'rm -rf "$TMP_DIR"' EXIT

log "===== Xibo Backup gestartet ====="

# --------------------------------------------------
# DB Fingerprint
# --------------------------------------------------
log "Berechne DB Fingerprint"

DB_HASH="$(
  docker exec "$DB_CONTAINER" mysql -N -B \
    -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" <<'SQL'
SELECT
  table_name,
  table_rows,
  data_length,
  index_length,
  auto_increment
FROM information_schema.tables
WHERE table_schema = DATABASE()
ORDER BY table_name;
SQL
)"
DB_HASH="$(printf '%s\n' "$DB_HASH" | sha256sum | awk '{print $1}')"

[[ -z "$DB_HASH" ]] && { log "FEHLER: DB_HASH leer"; exit 1; }

# --------------------------------------------------
# Media Fingerprint
# --------------------------------------------------
log "Berechne Media Fingerprint"

MEDIA_HASH="$(
  if [[ -d "$CMS_PATH" ]]; then
    find "$CMS_PATH" -type f -printf '%P|%s|%T@\n' \
      | sort | sha256sum | awk '{print $1}'
  else
    echo "no-media" | sha256sum | awk '{print $1}'
  fi
)"

# --------------------------------------------------
# Alten Zustand lesen
# --------------------------------------------------
read -r OLD_DB_HASH OLD_MEDIA_HASH < <(
  docker exec "$DB_CONTAINER" mysql -N -B \
    -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
    -e "SELECT db_hash, media_hash FROM backup_state WHERE id=1;"
)

OLD_DB_HASH="${OLD_DB_HASH:-}"
OLD_MEDIA_HASH="${OLD_MEDIA_HASH:-}"

log "DB_HASH=$DB_HASH"
log "MEDIA_HASH=$MEDIA_HASH"

DO_BACKUP=false
[[ "$DB_HASH" != "$OLD_DB_HASH" ]] && DO_BACKUP=true
[[ "$MEDIA_HASH" != "$OLD_MEDIA_HASH" ]] && DO_BACKUP=true

# --------------------------------------------------
# Backup
# --------------------------------------------------
if [[ "$DO_BACKUP" == true ]]; then
  BACKUP_FILE="$BACKUP_DIR/xibo_backup_$TIMESTAMP.zip"
  log "Änderung erkannt → erstelle Backup"

  docker exec "$DB_CONTAINER" mysqldump \
    --single-transaction \
    --quick \
    --skip-comments \
    --skip-dump-date \
    -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
    > "$TMP_DIR/db.sql"

  rsync -a "$CMS_PATH/" "$TMP_DIR/cms/"

  (cd "$TMP_DIR" && zip -rq "$BACKUP_FILE" .)

  docker exec "$DB_CONTAINER" mysql \
    -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" \
    -e "
      UPDATE backup_state
      SET db_hash='$DB_HASH',
          media_hash='$MEDIA_HASH'
      WHERE id=1;
    "

  log "Backup abgeschlossen: $BACKUP_FILE"
else
  log "Keine Änderungen → kein Backup"
fi

# --------------------------------------------------
# Retention
# --------------------------------------------------
mapfile -t BACKUPS < <(ls -1t "$BACKUP_DIR"/xibo_backup_*.zip 2>/dev/null || true)
COUNT="${#BACKUPS[@]}"

if (( COUNT > MAX_BACKUPS )); then
  for ((i=MAX_BACKUPS; i<COUNT; i++)); do
    rm -f "${BACKUPS[$i]}"
    log "Altes Backup gelöscht: ${BACKUPS[$i]}"
  done
fi

log "===== Backup beendet ====="
{% endraw %}
